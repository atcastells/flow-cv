import axios from 'axios';

// --- Updated Type Definitions ---

export interface FunctionDefinition {
  name: string;
  description?: string;
  parameters: Record<string, any>; // JSON Schema object
}

export interface ToolDefinition {
  type: 'function';
  function: FunctionDefinition;
}

export interface ToolCall {
  id: string; // ID generated by the model, needed to match response
  type: 'function';
  function: {
    name: string;
    arguments: string; // JSON string of arguments
  };
}

// Updated Message type
export interface Message {
  role: 'system' | 'user' | 'assistant' | 'tool';
  content: string | null; // Allow null for assistant messages with tool_calls
  name?: string; // Optional: Used by some APIs for tool role to identify the function
  tool_calls?: ToolCall[]; // Present for assistant role when requesting calls
  tool_call_id?: string; // Required for tool role messages to match the call ID
}

// Updated ChatCompletionRequest type
export interface ChatCompletionRequest {
  messages: Message[];
  model?: string;
  temperature?: number;
  max_tokens?: number;
  tools?: ToolDefinition[]; // Correctly defined
  // Updated toolChoice to include more standard options
  tool_choice?: 'auto' | 'none' | 'required' | { type: 'function'; function: { name: string } }; 
}

// Updated ChatCompletionResponseMessage (often mirrors Message but specific to response)
// We can potentially reuse the Message type if it covers all response fields,
// but defining a separate one can be clearer. Let's refine ChatCompletionResponse
export interface ChatCompletionResponseMessage extends Message {
    // Inherits role, content, name, tool_calls, tool_call_id from Message
    // Add any other fields specific to the response message if needed
    refusal?: any | null; // Example: If the API includes refusal info
}

// Updated ChatCompletionResponse type
export interface ChatCompletionResponse {
  id?: string; // Often included in response
  object?: string; // e.g., "chat.completion"
  created?: number; // Timestamp
  model?: string; // Model used for completion
  choices: {
    index?: number;
    message: ChatCompletionResponseMessage; // Use the refined response message type
    finish_reason: string | null; // e.g., "stop", "tool_calls", "length"
    logprobs?: any | null; // Optional log probabilities
  }[];
  usage?: { // Optional usage statistics
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
  provider?: string; // Added based on user examples
}


// --- Service Implementation ---

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

interface ModelInfo {
  id: string;
  name: string;
  pricing: {
    prompt: string;
    completion: string;
    image?: string; // Optional as not all models have it
    request?: string; // Optional
    input_cache_read?: string; // Optional
    input_cache_write?: string; // Optional
    web_search?: string; // Optional
    internal_reasoning?: string; // Optional
  };
  // Add other potential fields from OpenRouter's model info if needed
}

export class OpenRouterService {
  private apiKey: string;
  private defaultModel: string;

  constructor(apiKey: string, defaultModel = 'google/gemini-flash-1.5') { // Updated default model example
    if (!apiKey) {
      throw new Error("OpenRouter API key is required.");
    }
    this.apiKey = apiKey;
    this.defaultModel = defaultModel;
    console.log(`OpenRouterService initialized with model: ${this.defaultModel}`);
  }

  // getAvailableModels function remains largely the same, 
  // but made some pricing fields optional for broader compatibility
  async getAvailableModels(): Promise<ModelInfo[]> {
    try {
      const response = await axios.get<{ data: ModelInfo[] }>('https://openrouter.ai/api/v1/models', {
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          // Referer and X-Title are good practice for OpenRouter identification
          'HTTP-Referer': typeof window !== 'undefined' ? window.location.origin : 'http://localhost', // Handle server-side if necessary
          'X-Title': typeof window !== 'undefined' ? window.document.title || 'CV App' : 'CV App (SSR)', // Use app title
        }
      });

      // Updated filtering logic - adjust based on your actual needs (e.g., maybe allow non-zero request cost?)
      // This filter is very strict (only completely free models)
      return response.data.data.filter((model: ModelInfo) => {
        const pricing = model.pricing;
        return (
          pricing.prompt === '0' &&
          pricing.completion === '0' &&
          (pricing.image === '0' || !pricing.image) && // Handle optional fields
          (pricing.request === '0' || !pricing.request)
          // Add other pricing checks if needed
        );
      });
    } catch (error) {
      console.error("Error fetching OpenRouter models:", error);
      if (axios.isAxiosError(error)) {
        const apiError = error.response?.data?.error;
        const message = typeof apiError === 'string' ? apiError : apiError?.message;
        throw new Error(`OpenRouter API Error (Models): ${message || error.message}`);
      }
      throw error;
    }
  }

  // createChatCompletion method now uses the updated types
  async createChatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {
    const modelToUse = request.model || this.defaultModel;
    console.log(`Creating chat completion with model: ${modelToUse}`);

    // Basic validation before sending
    if (!request.messages || request.messages.length === 0) {
        throw new Error("Cannot send request with empty messages.");
    }

    try {
      const response = await axios.post<ChatCompletionResponse>( // Use the specific response type
        OPENROUTER_API_URL,
        {
          ...request, // Spread the original request
          model: modelToUse, // Ensure model is set
        },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json', // Explicitly set Content-Type
            'HTTP-Referer': typeof window !== 'undefined' ? window.location.origin : 'http://localhost',
            'X-Title': typeof window !== 'undefined' ? window.document.title || 'CV App' : 'CV App (SSR)',
          },
        }
      );

      // Refined response validation based on updated types
      if (!response.data || !Array.isArray(response.data.choices) || response.data.choices.length === 0) {
        console.error("Invalid response structure from OpenRouter:", response.data);
        throw new Error('Invalid response format: missing or empty choices array');
      }

      const firstChoice = response.data.choices[0];
      if (!firstChoice.message) {
         console.error("Invalid choice structure:", firstChoice);
        throw new Error('Invalid message format in API response choice');
      }
       
      // Validate the message content based on finish_reason
      const message = firstChoice.message;
      const finishReason = firstChoice.finish_reason;

      if (finishReason === 'tool_calls') {
          if (!message.tool_calls || message.tool_calls.length === 0) {
              console.error("Invalid response: finish_reason is 'tool_calls' but no tool_calls array found.", message);
              throw new Error("API indicated tool calls, but none were provided.");
          }
          // Content might be null or contain text, which is allowed
      } else if (finishReason === 'stop' || finishReason === 'length' || finishReason === null) { // Allow null finish_reason too
          if (typeof message.content !== 'string') { // Require string content if not stopping for tools
              console.error("Invalid response: finish_reason is stop/length/null but content is not a string.", message);
              // Allow empty string "" as valid content
              // throw new Error("API indicated stop/length but message content is missing or not a string.");
          }
      } // Add other finish_reason checks if needed

      return response.data; // Return the full validated response data

    } catch (error) {
      console.error(`Error during OpenRouter chat completion (Model: ${modelToUse}):`, error);
      if (axios.isAxiosError(error)) {
        const apiError = error.response?.data?.error;
        // Try to extract a more specific message from OpenRouter's error structure
        const message = typeof apiError === 'string' ? apiError : apiError?.message;
        throw new Error(`OpenRouter API Error: ${message || error.message} (Status: ${error.response?.status})`);
      }
      // Re-throw other types of errors
      throw error;
    }
  }
}