import axios from 'axios';

// --- Updated Type Definitions ---

export interface FunctionDefinition {
  name: string;
  description?: string;
  parameters: Record<string, any>; // JSON Schema object
}

export interface ToolDefinition {
  type: 'function';
  function: FunctionDefinition;
}

export interface ToolCall {
  id: string; // ID generated by the model, needed to match response
  type: 'function';
  function: {
    name: string;
    arguments: string; // JSON string of arguments
  };
}

// --- Types for Multimodal Content ---
// Represents a text part of the message content
export type TextPart = { type: "text"; text: string };

// Represents an image part of the message content
// The 'url' should be a Data URI (Base64 encoded) or potentially a public HTTPS URL
// depending on the model's capabilities via OpenRouter. Base64 is generally safer for uploads.
export type ImageUrl = { url: string; detail?: "low" | "high" | "auto" }; // detail is optional
export type ImageUrlPart = { type: "image_url"; image_url: ImageUrl };

// A single part of the message content (either text or image)
export type ContentPart = TextPart | ImageUrlPart;

// --- Updated Message Type ---
export interface Message {
  role: 'system' | 'user' | 'assistant' | 'tool';
  // Content can be a simple string, null (for tool calls), or an array for multimodal input
  content: string | null | ContentPart[]; 
  name?: string; // Optional: Used by some APIs for tool role to identify the function
  tool_calls?: ToolCall[]; // Present for assistant role when requesting calls
  tool_call_id?: string; // Required for tool role messages to match the call ID
  // REMOVED 'files?: File[]' - This is NOT the standard way to send files via API.
  // File data MUST be converted to Base64 Data URI and included in the 'content' array.
}

// Updated ChatCompletionRequest type
export interface ChatCompletionRequest {
  messages: Message[]; // Uses the updated Message type
  model?: string;
  temperature?: number;
  max_tokens?: number;
  tools?: ToolDefinition[]; 
  tool_choice?: 'auto' | 'none' | 'required' | { type: 'function'; function: { name: string } }; 
}

// Updated ChatCompletionResponseMessage type
export interface ChatCompletionResponseMessage extends Message {
    // Allows content to be string | null | ContentPart[]
    refusal?: any | null; 
}

// Updated ChatCompletionResponse type
export interface ChatCompletionResponse {
  id?: string; 
  object?: string; 
  created?: number; 
  model?: string; 
  choices: {
    index?: number;
    message: ChatCompletionResponseMessage; 
    finish_reason: string | null; 
    logprobs?: any | null; 
  }[];
  usage?: { 
    prompt_tokens: number;
    completion_tokens: number;
    total_tokens: number;
  };
  provider?: string; 
}


// --- Service Implementation ---

const OPENROUTER_API_URL = 'https://openrouter.ai/api/v1/chat/completions';

interface ModelInfo {
  id: string;
  name: string;
  // Includes other fields like pricing, context_length, etc.
  pricing: { /* ... */ }; 
}

export class OpenRouterService {
  private apiKey: string;
  private defaultModel: string;

  constructor(apiKey: string, defaultModel = 'google/gemini-flash-1.5') { 
    if (!apiKey) {
      throw new Error("OpenRouter API key is required.");
    }
    this.apiKey = apiKey;
    this.defaultModel = defaultModel;
    console.log(`OpenRouterService initialized with model: ${this.defaultModel}`);
  }

  async getAvailableModels(): Promise<ModelInfo[]> {
      // Logic remains the same - fetches model list
      // ... (implementation from your previous code) ...
      try {
          const response = await axios.get<{ data: ModelInfo[] }>('https://openrouter.ai/api/v1/models', {
              headers: { /* ... headers ... */ }
          });
          // Your filtering logic...
          return response.data.data.filter((model: any) => { /* ... filter ... */ });
      } catch (error) {
          // Your error handling...
          console.error("Error fetching OpenRouter models:", error);
          if (axios.isAxiosError(error)) { /* ... */ }
          throw error;
      }
  }


  // createChatCompletion method does NOT need changes in its internal logic.
  // It correctly sends the 'request' object it receives.
  // The key is that the 'request.messages' array passed TO this function
  // must be correctly formatted with the ContentPart[] structure by the calling code (useChat hook / ChatWindow).
  async createChatCompletion(request: ChatCompletionRequest): Promise<ChatCompletionResponse> {
    const modelToUse = request.model || this.defaultModel;
    console.log(`Creating chat completion with model: ${modelToUse}`);
    
    if (!request.messages || request.messages.length === 0) {
        throw new Error("Cannot send request with empty messages.");
    }

    // Make sure a multimodal model is selected if sending image data
    const hasImage = request.messages.some(msg => 
        Array.isArray(msg.content) && msg.content.some(part => part.type === 'image_url')
    );
    if (hasImage) {
        // Basic check - Ideally fetch model details to confirm multimodal support
        console.warn(`Sending image data. Ensure model '${modelToUse}' supports multimodal input.`);
        // You might add a check here against a known list of multimodal models if needed
    }


    try {
      const response = await axios.post<ChatCompletionResponse>(
        OPENROUTER_API_URL,
        {
          ...request, 
          model: modelToUse, 
        },
        {
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
            'HTTP-Referer': typeof window !== 'undefined' ? window.location.origin : 'http://localhost',
            'X-Title': typeof window !== 'undefined' ? window.document.title || 'CV App' : 'CV App (SSR)',
          },
        }
      );

      // Validation logic remains the same, it handles the structure correctly
      if (!response.data || !Array.isArray(response.data.choices) || response.data.choices.length === 0) { /* ... error ... */ throw new Error('Invalid response format: missing or empty choices array'); }
      const firstChoice = response.data.choices[0];
      if (!firstChoice.message) { /* ... error ... */ throw new Error('Invalid message format in API response choice');}
      const message = firstChoice.message;
      const finishReason = firstChoice.finish_reason;
      if (finishReason === 'tool_calls') { /* ... validation ... */ } 
      else if (finishReason === 'stop' || finishReason === 'length' || finishReason === null) { /* ... validation ... */ }
      
      return response.data; 

    } catch (error) {
        // Error handling remains the same
        console.error(`Error during OpenRouter chat completion (Model: ${modelToUse}):`, error);
        if (axios.isAxiosError(error)) { /* ... */ }
        throw error;
    }
  }
}